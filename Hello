public RestTemplate getRestTemplate() {

        try {
            final KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(keyStoreFile.getInputStream(), keyPassword.toCharArray());


            final SSLContext sslContext = new SSLContextBuilder()
                    .loadTrustMaterial(keyStoreFile.getURL(), keyPassword.toCharArray(), (X509Certificate[] chain, String authType) -> true)
                    .loadKeyMaterial(keyStore, keyPassword.toCharArray())
                    .build();
            final SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(sslContext, INSTANCE);

            final HttpClient httpClient = custom()
                    .setSSLSocketFactory(socketFactory)
                    .build();

            final HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);

            final RestTemplate restTemplate = new RestTemplate();
            restTemplate.setRequestFactory(new BufferingClientHttpRequestFactory(requestFactory));

            return restTemplate;
        } catch (IOException e) {
            log.error("....", e);
            throw new ApiException(e);
        } catch (Exception e) {
            log.error("....", e);
            throw new ApiException(e);
        }
    }








// Assuming your entity classes are properly defined

public class TableConverter {
    public static List<Section> convertToStructuredObjects(List<List<String>> records) {
        Map<String, Section> sectionMap = new LinkedHashMap<>();

        for (List<String> record : records) {
            String sectionName = record.get(0);
            String subsectionName = record.get(1);
            String questionSubsectionName = record.get(2);
            String question = record.get(3);
            String options = record.get(4); // This should be a comma-separated list
            String answer = record.get(5);

            List<String> optionsList = new ArrayList<>();
            if (options != null && !options.isEmpty()) {
                String[] optionsArray = options.split(",");
                optionsList.addAll(Arrays.asList(optionsArray));
            }

            OptionChoiceRepository optionChoiceRepository = /* Inject your OptionChoice repository here */;
            TableEntry tableEntry = new TableEntry();
            for (String option : optionsList) {
                OptionChoice optionChoice = new OptionChoice();
                optionChoice.setOptionChoiceName(option);
                optionChoice.setTableEntry(tableEntry);
                optionChoiceRepository.save(optionChoice);
            }

            sectionMap.computeIfAbsent(sectionName, Section::new)
                    .getSubsection(subsectionName)
                    .getQuestionSubsection(questionSubsectionName)
                    .addQuestion(new TableEntry(question, answer, optionsList));
        }

        return new ArrayList<>(sectionMap.values());
    }

    public static void main(String[] args) {
        List<List<String>> records = /* Your list of records, each record being a list of strings */;
        List<Section> structuredObjects = convertToStructuredObjects(records);

        SectionRepository sectionRepository = /* Inject your Section repository here */;
        sectionRepository.saveAll(structuredObjects);
    }
}
